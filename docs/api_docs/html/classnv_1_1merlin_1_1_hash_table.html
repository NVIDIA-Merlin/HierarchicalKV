<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Merlin HKVS: nv::merlin::HashTable&lt; K, V, BaseV, T, M, DIM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="merlin-hkvs.png"/></td>
  <td id="projectalign">
   <div id="projectname">Merlin HKVS<span id="projectnumber">&#160;v0.2.0</span>
   </div>
   <div id="projectbrief">Merlin Hierarchical Key-Value Storage</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nv</b></li><li class="navelem"><b>merlin</b></li><li class="navelem"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnv_1_1merlin_1_1_hash_table-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nv::merlin::HashTable&lt; K, V, BaseV, T, M, DIM &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee68ee8f95900089f77b4927e624d3f5"><td class="memItemLeft" align="right" valign="top"><a id="aee68ee8f95900089f77b4927e624d3f5" name="aee68ee8f95900089f77b4927e624d3f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Table</b> = nv::merlin::Table&lt; K, V, M, DIM &gt;</td></tr>
<tr class="separator:aee68ee8f95900089f77b4927e624d3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb2c80fa1792de76a46ab7c3e48cd49"><td class="memItemLeft" align="right" valign="top"><a id="a0bb2c80fa1792de76a46ab7c3e48cd49" name="a0bb2c80fa1792de76a46ab7c3e48cd49"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Initializer</b> = nv::merlin::initializers::Initializer&lt; T &gt;</td></tr>
<tr class="separator:a0bb2c80fa1792de76a46ab7c3e48cd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad45aeec670a4065072c44788aec80a"><td class="memItemLeft" align="right" valign="top"><a id="afad45aeec670a4065072c44788aec80a" name="afad45aeec670a4065072c44788aec80a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Zeros</b> = nv::merlin::initializers::Zeros&lt; T &gt;</td></tr>
<tr class="separator:afad45aeec670a4065072c44788aec80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a011b62c75f9ec972b3215900216cdf13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a011b62c75f9ec972b3215900216cdf13">HashTable</a> (uint64_t max_size, const Initializer *initializer=nullptr, bool master=true)</td></tr>
<tr class="memdesc:a011b62c75f9ec972b3215900216cdf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">merlin::HashTable</a>. <a href="classnv_1_1merlin_1_1_hash_table.html#a011b62c75f9ec972b3215900216cdf13">More...</a><br /></td></tr>
<tr class="separator:a011b62c75f9ec972b3215900216cdf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4849afa081f189759297cebbc9d490a2"><td class="memItemLeft" align="right" valign="top"><a id="a4849afa081f189759297cebbc9d490a2" name="a4849afa081f189759297cebbc9d490a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~HashTable</b> ()</td></tr>
<tr class="memdesc:a4849afa081f189759297cebbc9d490a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the contents of the table and destroys the table object. <br /></td></tr>
<tr class="separator:a4849afa081f189759297cebbc9d490a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd46ce1d0b3d14cddc15eaa384c96c7d"><td class="memItemLeft" align="right" valign="top"><a id="acd46ce1d0b3d14cddc15eaa384c96c7d" name="acd46ce1d0b3d14cddc15eaa384c96c7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HashTable</b> (const <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> &amp;)=delete</td></tr>
<tr class="separator:acd46ce1d0b3d14cddc15eaa384c96c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791150159ac5847a42e78710138e50f"><td class="memItemLeft" align="right" valign="top"><a id="af791150159ac5847a42e78710138e50f" name="af791150159ac5847a42e78710138e50f"></a>
<a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> &amp;)=delete</td></tr>
<tr class="separator:af791150159ac5847a42e78710138e50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce4e651b7a6e47fe3cf0156a9de988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a53ce4e651b7a6e47fe3cf0156a9de988">upsert</a> (const K *d_keys, const BaseV *d_vals, size_t len, cudaStream_t stream, bool allow_duplicate_keys=true)</td></tr>
<tr class="memdesc:a53ce4e651b7a6e47fe3cf0156a9de988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert key-values pairs into the table. If one key already exists, the value of the key will be updated.  <a href="classnv_1_1merlin_1_1_hash_table.html#a53ce4e651b7a6e47fe3cf0156a9de988">More...</a><br /></td></tr>
<tr class="separator:a53ce4e651b7a6e47fe3cf0156a9de988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643a40e5ef412f4b6b8a3d63df5e79e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#af643a40e5ef412f4b6b8a3d63df5e79e">upsert</a> (const K *d_keys, const BaseV *d_vals, const M *d_metas, size_t len, cudaStream_t stream, bool allow_duplicate_keys=true)</td></tr>
<tr class="memdesc:af643a40e5ef412f4b6b8a3d63df5e79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert key-value-mata tuples into the table. If one key already exists, the value of the key will be updated.  <a href="classnv_1_1merlin_1_1_hash_table.html#af643a40e5ef412f4b6b8a3d63df5e79e">More...</a><br /></td></tr>
<tr class="separator:af643a40e5ef412f4b6b8a3d63df5e79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6622576331e16f4a1f15f8ce222474b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a6622576331e16f4a1f15f8ce222474b4">accum</a> (const K *d_keys, const BaseV *d_vals_or_deltas, const bool *d_exists, size_t len, cudaStream_t stream, bool allow_duplicate_keys=true)</td></tr>
<tr class="separator:a6622576331e16f4a1f15f8ce222474b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148a3dbdb48c56aa66a89d836d9f416f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a148a3dbdb48c56aa66a89d836d9f416f">get</a> (const K *d_keys, BaseV *d_vals, bool *d_status, size_t len, BaseV *d_def_val, cudaStream_t stream, bool full_size_default) const</td></tr>
<tr class="memdesc:a148a3dbdb48c56aa66a89d836d9f416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the table for the specified keys.  <a href="classnv_1_1merlin_1_1_hash_table.html#a148a3dbdb48c56aa66a89d836d9f416f">More...</a><br /></td></tr>
<tr class="separator:a148a3dbdb48c56aa66a89d836d9f416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2226095a1b844d45bfb48427df0cffef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a2226095a1b844d45bfb48427df0cffef">get</a> (const K *d_keys, BaseV *d_vals, M *d_metas, bool *d_status, size_t len, BaseV *d_def_val, cudaStream_t stream, bool full_size_default) const</td></tr>
<tr class="memdesc:a2226095a1b844d45bfb48427df0cffef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the table for the specified keys.  <a href="classnv_1_1merlin_1_1_hash_table.html#a2226095a1b844d45bfb48427df0cffef">More...</a><br /></td></tr>
<tr class="separator:a2226095a1b844d45bfb48427df0cffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe87108132f07d270e21e41a38c6d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a6fe87108132f07d270e21e41a38c6d78">get</a> (const K *d_keys, BaseV *d_vals, size_t len, cudaStream_t stream) const</td></tr>
<tr class="memdesc:a6fe87108132f07d270e21e41a38c6d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the table for the specified keys.  <a href="classnv_1_1merlin_1_1_hash_table.html#a6fe87108132f07d270e21e41a38c6d78">More...</a><br /></td></tr>
<tr class="separator:a6fe87108132f07d270e21e41a38c6d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b807f774d049eaf3dc2aa5e6b80ec8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a04b807f774d049eaf3dc2aa5e6b80ec8">get_size</a> (cudaStream_t stream) const</td></tr>
<tr class="memdesc:a04b807f774d049eaf3dc2aa5e6b80ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the table size.  <a href="classnv_1_1merlin_1_1_hash_table.html#a04b807f774d049eaf3dc2aa5e6b80ec8">More...</a><br /></td></tr>
<tr class="separator:a04b807f774d049eaf3dc2aa5e6b80ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf652b281936630ece4d15fbfb732b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#acbf652b281936630ece4d15fbfb732b8">get_capacity</a> () const</td></tr>
<tr class="memdesc:acbf652b281936630ece4d15fbfb732b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the table capacity.  <a href="classnv_1_1merlin_1_1_hash_table.html#acbf652b281936630ece4d15fbfb732b8">More...</a><br /></td></tr>
<tr class="separator:acbf652b281936630ece4d15fbfb732b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eca6dfd87fa7e79a19bfc75576c4bd"><td class="memItemLeft" align="right" valign="top"><a id="a04eca6dfd87fa7e79a19bfc75576c4bd" name="a04eca6dfd87fa7e79a19bfc75576c4bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (cudaStream_t stream)</td></tr>
<tr class="memdesc:a04eca6dfd87fa7e79a19bfc75576c4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all of the contents in the table with no release object. <br /></td></tr>
<tr class="separator:a04eca6dfd87fa7e79a19bfc75576c4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48c1d9a3728d2f05d43d805cd700c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#ac48c1d9a3728d2f05d43d805cd700c4b">remove</a> (const K *d_keys, size_t len, cudaStream_t stream)</td></tr>
<tr class="memdesc:ac48c1d9a3728d2f05d43d805cd700c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the specified keys in the table.  <a href="classnv_1_1merlin_1_1_hash_table.html#ac48c1d9a3728d2f05d43d805cd700c4b">More...</a><br /></td></tr>
<tr class="separator:ac48c1d9a3728d2f05d43d805cd700c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2a2e9bd5b76680bc1b4d15b9b90b69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#acb2a2e9bd5b76680bc1b4d15b9b90b69">dump</a> (K *d_key, BaseV *d_val, const size_t offset, const size_t search_length, size_t *d_dump_counter, cudaStream_t stream) const</td></tr>
<tr class="memdesc:acb2a2e9bd5b76680bc1b4d15b9b90b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export all of the Key-value pairs in the table.  <a href="classnv_1_1merlin_1_1_hash_table.html#acb2a2e9bd5b76680bc1b4d15b9b90b69">More...</a><br /></td></tr>
<tr class="separator:acb2a2e9bd5b76680bc1b4d15b9b90b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de849237ef4b168fa058b69eb74865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html#a99de849237ef4b168fa058b69eb74865">dump</a> (K *d_key, BaseV *d_val, M *d_metas, const size_t offset, const size_t search_length, size_t *d_dump_counter, cudaStream_t stream) const</td></tr>
<tr class="memdesc:a99de849237ef4b168fa058b69eb74865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export all of the key-value-meta tuples in the table.  <a href="classnv_1_1merlin_1_1_hash_table.html#a99de849237ef4b168fa058b69eb74865">More...</a><br /></td></tr>
<tr class="separator:a99de849237ef4b168fa058b69eb74865"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class K, class V, class BaseV, class T, class M, size_t DIM&gt;<br />
class nv::merlin::HashTable&lt; K, V, BaseV, T, M, DIM &gt;</div><p >Merlin <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> is a concurrent and hierarchical <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> powered by GPUs which can use both HBM and HMEM as storage for Key-Values. At the same time, the performance of it is close those <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">HashTable</a> running on the pure HBM.</p>
<dl class="section note"><dt>Note</dt><dd>Supports concurrent upsert, but not concurrent upsert and find now. The upsert means insert or update if already exists.</dd>
<dd>
There is no API eviction and the eviction will happen automatically when table is almost full. We introduce a <code>meta</code> concept to help implement it. The keys with minimum meta will be evicted with priority. So the meta usually is the timestamp or times of the key occurrence. The user can also customize the meaning of the value that is equivalent to customizing the eviction policy.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>type of the key </td></tr>
    <tr><td class="paramname">V</td><td>type of the Value and must be merlin::ValueArray&lt;T, DIM&gt;. </td></tr>
    <tr><td class="paramname">BaseV</td><td>type of the Value and must be merlin::ValueType. </td></tr>
    <tr><td class="paramname">T</td><td>type of the Value's item type, which should be basic types of C++/CUDA. </td></tr>
    <tr><td class="paramname">M</td><td>type of the meta and must be uint64_t in this release. </td></tr>
    <tr><td class="paramname">DIM</td><td>dimension of the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>:<ul>
<li>Support dynamic rehashing</li>
<li>Support the semantics of iterator::begin() and iterator::end()</li>
<li>Support SSD/NVMe device as part of storage </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a011b62c75f9ec972b3215900216cdf13" name="a011b62c75f9ec972b3215900216cdf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011b62c75f9ec972b3215900216cdf13">&#9670;&nbsp;</a></span>HashTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::HashTable </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Initializer *&#160;</td>
          <td class="paramname"><em>initializer</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>master</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">merlin::HashTable</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>The maximum number of pairs the map may hold. </td></tr>
    <tr><td class="paramname">initializer</td><td>Initializer used when getting a key fail. </td></tr>
    <tr><td class="paramname">master</td><td>No used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6622576331e16f4a1f15f8ce222474b4" name="a6622576331e16f4a1f15f8ce222474b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6622576331e16f4a1f15f8ce222474b4">&#9670;&nbsp;</a></span>accum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::accum </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseV *&#160;</td>
          <td class="paramname"><em>d_vals_or_deltas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>d_exists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_duplicate_keys</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Searches for each key in <code>d_keys</code> in the table. If the key is found and corresponding exist in <code>d_exists</code> is true, the <code>d_vals_or_deltas</code> will be treated as delta against to the old value, and the delta will be add to the old value of the key. If the key is not found and corresponding exist in <code>d_exists</code> is false, the <code>d_vals_or_deltas</code> will be treated as a new value and the key-value pair will be updated into the table directly.</p>
<dl class="section note"><dt>Note</dt><dd>Specially when the key is found and exist is false, or the key is not found and exist is true, nothing will be changed and this accum will be ignored, for we assume these situations occur while the key was modified or removed by other processes just now.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals_or_deltas</td><td>The values to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_exists</td><td>The metas to be inserted on GPU accessible memory. The metas usually are with uint64_t value which stand for the timestamp of the key inserted or the number of the key occurrences. </td></tr>
    <tr><td class="paramname">d_exists</td><td>if the key exists when last find in this process. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value pairs to be upsert. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation </td></tr>
    <tr><td class="paramname">allow_duplicate_keys</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>support accum with metas. </dd></dl>

</div>
</div>
<a id="acb2a2e9bd5b76680bc1b4d15b9b90b69" name="acb2a2e9bd5b76680bc1b4d15b9b90b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2a2e9bd5b76680bc1b4d15b9b90b69">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>d_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>search_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_dump_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export all of the Key-value pairs in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be dumped on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be dumped on GPU accessible memory. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of Key to be removed. </td></tr>
    <tr><td class="paramname">search_length</td><td>Maximum number of dumped pairs. </td></tr>
    <tr><td class="paramname">d_dump_counter</td><td>A pointer of counter on GPU accessible memory indicates the number of key-value pairs dumped. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a99de849237ef4b168fa058b69eb74865" name="a99de849237ef4b168fa058b69eb74865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99de849237ef4b168fa058b69eb74865">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">K *&#160;</td>
          <td class="paramname"><em>d_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M *&#160;</td>
          <td class="paramname"><em>d_metas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>search_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_dump_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export all of the key-value-meta tuples in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be dumped on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be dumped on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_metas</td><td>The metas to be dumped on GPU accessible memory. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of Key to be removed. </td></tr>
    <tr><td class="paramname">search_length</td><td>Maximum number of dumped pairs which helps caller control the memory consuming on each calling. </td></tr>
    <tr><td class="paramname">d_dump_counter</td><td>A pointer of counter on GPU accessible memory indicates the number of key-value-meta tuples dumped. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a148a3dbdb48c56aa66a89d836d9f416f" name="a148a3dbdb48c56aa66a89d836d9f416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148a3dbdb48c56aa66a89d836d9f416f">&#9670;&nbsp;</a></span>get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>d_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_size_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the table for the specified keys. </p>
<dl class="section note"><dt>Note</dt><dd>When a key is missing, a default value in <code>d_def_val</code> will returned. Specially, if <code>full_size_default</code> is true, <code>d_def_val</code> will be treated as a BaseV array with <code>len</code>, at this situation, each keys will have a different default value, or if <code>full_size_default</code> is true, the <code>d_def_val</code> only contains one default and each keys will share it when missed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_status</td><td>The status indicates if the keys are found. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value pairs to be searched. </td></tr>
    <tr><td class="paramname">d_def_val</td><td>The default values for each keys on GPU accessible memory. If the keys are missing, the values in it will be returned.</td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation. </td></tr>
    <tr><td class="paramname">full_size_default</td><td>Flag of if allow the <code>d_keys</code> contains duplicate keys. If false, the caller should guarantee the <code>d_keys</code> has no duplicate keys, and the performance will be better.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a2226095a1b844d45bfb48427df0cffef" name="a2226095a1b844d45bfb48427df0cffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2226095a1b844d45bfb48427df0cffef">&#9670;&nbsp;</a></span>get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M *&#160;</td>
          <td class="paramname"><em>d_metas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>d_status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full_size_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the table for the specified keys. </p>
<dl class="section note"><dt>Note</dt><dd>When a key is missing, a default value in <code>d_def_val</code> will returned. Specially, if <code>full_size_default</code> is true, <code>d_def_val</code> will be treated as a BaseV array with <code>len</code>, at this situation, each keys will have a different default value, or if <code>full_size_default</code> is true, the <code>d_def_val</code> only contains one default and each keys will share it when missed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_metas</td><td>The metas to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_status</td><td>The status indicates if the keys are found. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value-Meta tuples to be searched. </td></tr>
    <tr><td class="paramname">d_def_val</td><td>The default values for each keys on GPU accessible memory. If the keys are missing, the values in it will be returned.</td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation. </td></tr>
    <tr><td class="paramname">full_size_default</td><td>Flag of if allow the <code>d_keys</code> contains duplicate keys. If false, the caller should guarantee the <code>d_keys</code> has no duplicate keys, and the performance will be better.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a6fe87108132f07d270e21e41a38c6d78" name="a6fe87108132f07d270e21e41a38c6d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe87108132f07d270e21e41a38c6d78">&#9670;&nbsp;</a></span>get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseV *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the table for the specified keys. </p>
<dl class="section note"><dt>Note</dt><dd>When a key is missing, a value initialized by this-&gt;initializer_ will returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be searched on GPU accessible memory. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value pairs to be searched.</td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="acbf652b281936630ece4d15fbfb732b8" name="acbf652b281936630ece4d15fbfb732b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf652b281936630ece4d15fbfb732b8">&#9670;&nbsp;</a></span>get_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::get_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the table capacity. </p>
<dl class="section note"><dt>Note</dt><dd>The capacity is requested by the caller and the value may be less than the actual capacity of the table because the table keeps the capacity to be the power of 2 for performance consideration.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The table capacity </dd></dl>

</div>
</div>
<a id="a04b807f774d049eaf3dc2aa5e6b80ec8" name="a04b807f774d049eaf3dc2aa5e6b80ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b807f774d049eaf3dc2aa5e6b80ec8">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::get_size </td>
          <td>(</td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the table size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The table size </dd></dl>

</div>
</div>
<a id="ac48c1d9a3728d2f05d43d805cd700c4b" name="ac48c1d9a3728d2f05d43d805cd700c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48c1d9a3728d2f05d43d805cd700c4b">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the specified keys in the table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be removed on GPU accessible memory. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key to be removed. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af643a40e5ef412f4b6b8a3d63df5e79e" name="af643a40e5ef412f4b6b8a3d63df5e79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643a40e5ef412f4b6b8a3d63df5e79e">&#9670;&nbsp;</a></span>upsert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseV *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M *&#160;</td>
          <td class="paramname"><em>d_metas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_duplicate_keys</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert key-value-mata tuples into the table. If one key already exists, the value of the key will be updated. </p>
<dl class="section note"><dt>Note</dt><dd>When the table is already full, the keys to be replaced are the keys with minimum meta value. If the meta of the new key is even less than minimum meta of the target bucket, the key will not be insert.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_metas</td><td>The metas to be inserted on GPU accessible memory. The metas usually are with uint64_t value which stand for the timestamp of the key inserted or the number of the key occurrences.</td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value-Meta tuples to be upsert. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation. </td></tr>
    <tr><td class="paramname">allow_duplicate_keys</td><td>Flag of if allow the <code>d_keys</code> contains duplicate keys. If false, the caller should guarantee the <code>d_keys</code> has no duplicate keys, and the performance will be better. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a53ce4e651b7a6e47fe3cf0156a9de988" name="a53ce4e651b7a6e47fe3cf0156a9de988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ce4e651b7a6e47fe3cf0156a9de988">&#9670;&nbsp;</a></span>upsert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class BaseV , class T , class M , size_t DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnv_1_1merlin_1_1_hash_table.html">nv::merlin::HashTable</a>&lt; K, V, BaseV, T, M, DIM &gt;::upsert </td>
          <td>(</td>
          <td class="paramtype">const K *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BaseV *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_duplicate_keys</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert key-values pairs into the table. If one key already exists, the value of the key will be updated. </p>
<dl class="section note"><dt>Note</dt><dd>When the table is already full, the LRU policy will be applied: the key to be replaced is least recently inserted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d_keys</td><td>The keys to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">d_vals</td><td>The values to be inserted on GPU accessible memory. </td></tr>
    <tr><td class="paramname">len</td><td>Number of Key-Value pairs to be upsert. </td></tr>
    <tr><td class="paramname">stream</td><td>The CUDA stream used to execute the operation. </td></tr>
    <tr><td class="paramname">allow_duplicate_keys</td><td>Flag of if allow the <code>d_keys</code> contains duplicate keys. If false, the caller should guarantee the <code>d_keys</code> has no duplicate keys, and the performance will be better. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/workplace/code/00-github/merlin-hkvs/cpp/include/merlin_hashtable.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
